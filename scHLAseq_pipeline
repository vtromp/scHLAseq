#!/usr/bin/env bash

# Resolve the absolute path to the directory where this script is located, allowing helper scripts and resources to be referenced reliably regardless of the current working directory or how the script was invoked
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# -------------------------------
# Initialize variables
# -------------------------------

# Empty variables to store user-provided paths
FASTQS=""
REF_TRANSCRIPTOME=""
OUTPUT_DIR=""
TEMP_DIR=""


# -------------------------------
# Define a help/usage function
# -------------------------------

# Explain each expected command-line option
usage() {
  echo "Usage: $0 -f <FASTQ_DIR> -l <READ_LENGTH> -r <REF_TRANSCRIPTOME_DIR> -o <OUTPUT_DIR> -t <TEMP_DIR>"
  echo
  echo "  -f FASTQ_DIR              Directory containing sequencing FASTQ files"
  echo "  -r REF_TRANSCRIPTOME_DIR  Path to CellRanger-compatible reference transcriptome"
  echo "  -o OUTPUT_DIR             Output directory"
  echo "  -t TEMP_DIR               Temporary directory"
  echo
  exit 1
}


# -------------------------------
# Parse command-line options using getopts
# -------------------------------

# Parse command-line options
while getopts ":f:r:o:t:h" opt; do
  case $opt in
    f) FASTQS="$OPTARG" ;;
    r) REF_TRANSCRIPTOME="$OPTARG" ;;
    o) OUTPUT_DIR="$OPTARG" ;;
    t) TEMP_DIR="$OPTARG" ;;
    h) usage ;;
    \?) echo "Invalid option -$OPTARG"; usage ;;
    :) echo "Option -$OPTARG requires an argument"; usage ;;
  esac
done

# Remove trailing slash (if present)
FASTQS=${FASTQS%/}
REF_TRANSCRIPTOME=${REF_TRANSCRIPTOME%/}
OUTPUT_DIR=${OUTPUT_DIR%/}
TEMP_DIR=${TEMP_DIR%/}

# Append the FASTQ directory name to the output path to create a sample-specific output directory
OUTPUT_DIR=$OUTPUT_DIR/$(basename $FASTQS)_scHLAseq


# -------------------------------
# Run cellranger count
# ------------------------------- 

# Create output directory for cellranger count
mkdir -p $OUTPUT_DIR/cellranger_count/

# Run the Cell Ranger count pipeline and write BAM files and all output results to 'cellranger_count' directory in output folder
cellranger count --id cellranger_count \
  --fastqs $FASTQS \
  --transcriptome $REF_TRANSCRIPTOME \
  --create-bam true \
  --output-dir $OUTPUT_DIR/cellranger_count \
  --localcores $(nproc) \
  --localmem $(awk '/MemAvailable/ {printf "%.0f\n", $2/1024/1024}' /proc/meminfo)


# -------------------------------
# Extract reads mapping to HLA class II genes and unmapped reads
# ------------------------------- 

# Generates a TSV file containing, for each molecule assigned to an HLA class II gene, the corresponding cell barcode (CB) and UMI (UB) combination
$SCRIPT_DIR/scripts/extract.HLAclassII.molecule.info.R -c $OUTPUT_DIR/cellranger_count -o $OUTPUT_DIR/hla_molecule_info.tsv

# Extract the filtered cell barcodes from Cell Ranger output
zcat $OUTPUT_DIR/cellranger_count/outs/filtered_feature_bc_matrix/barcodes.tsv.gz > $OUTPUT_DIR/filtered_barcodes.txt
# Create a CB_UB list from the previously generated HLA molecule info file
awk '{print $1 "_" $2}' $OUTPUT_DIR/hla_molecule_info.tsv > $OUTPUT_DIR/barcode_umi_pairs.txt

# Filter the BAM to keep only reads whose CB-UB pair is in 'barcode_umi_pairs.txt'
samtools view -h $OUTPUT_DIR/cellranger_count/outs/possorted_genome_bam.bam | awk -v keyfile=$OUTPUT_DIR/barcode_umi_pairs.txt '
BEGIN { while ((getline < keyfile) > 0) keep[$1]=1 }
{
    # Pass through headers unchanged
    if ($0 ~ /^@/) { print; next }
    # For each read, parse CB and UB tags
    for (i=12; i<=NF; i++)
        if ($i ~ /^CB:Z:/) cb=substr($i,6)
        else if ($i ~ /^UB:Z:/) ub=substr($i,6)
    # If both CB and UB exist and the pair is in the whitelist, keep the read
    if (cb && ub && keep[cb "_" ub]) print
    cb=ub=""
}' \
| samtools view -b -o $OUTPUT_DIR/hla_class_II_reads.bam
# Index the filtered BAM file
samtools index $OUTPUT_DIR/hla_class_II_reads.bam

# Filter BAM for unmapped reads that have CB and UB tags and whose CB is in 'filtered_barcodes.txt'
samtools view -h $OUTPUT_DIR/cellranger_count/outs/possorted_genome_bam.bam | awk -v keyfile=$OUTPUT_DIR/filtered_barcodes.txt '
BEGIN { while ((getline < keyfile) > 0) keep[$1]=1 }
{
    # Pass through headers unchanged
    if ($0 ~ /^@/) { print; next }
    # Keep only unmapped reads (FLAG 0x4)
    if (and($2, 4) == 0) next
    cb=""; ub=""
    for (i=12; i<=NF; i++) {
        if ($i ~ /^CB:Z:/) cb=substr($i,6)
        else if ($i ~ /^UB:Z:/) ub=substr($i,6)
    }
    # If CB and UB exist and CB is in whitelist, keep the read
    if (cb!="" && ub!="" && keep[cb]) print
}' \
| samtools view -b -o $OUTPUT_DIR/unmapped_reads.bam
# Index the filtered BAM file
samtools index $OUTPUT_DIR/unmapped_reads.bam

# Remove the 'filtered_barcodes.txt' and 'barcodes_umis.txt' files
rm $OUTPUT_DIR/filtered_barcodes.txt $OUTPUT_DIR/barcode_umi_pairs.txt

# Convert HLA class II reads to FASTQ
samtools fastq $OUTPUT_DIR/hla_class_II_reads.bam > $OUTPUT_DIR/extracted_reads.fastq
# Append unmapped reads to the same FASTQ file
samtools fastq $OUTPUT_DIR/unmapped_reads.bam >> $OUTPUT_DIR/extracted_reads.fastq

# Write TSV header
echo -e "read.id\tbarcode\tumi\tchr\tpos\tgene\tregion\talignment.flag" > $OUTPUT_DIR/extracted_reads.tsv

# Extract read ID, cell barcode (CB), UMI (UB), genomic position, gene name (GN), region annotation (RE), and alignment flag (xf) from the HLA class II BAM file and append the results as a TSV-formatted table
samtools view $OUTPUT_DIR/hla_class_II_reads.bam | \
awk '{
  read_id = $1
  chr = $3
  pos = $4
  cb = ub = re = gn = xf = "NA"
  for(i=12;i<=NF;i++){
    if($i ~ /^CB:Z:/) { cb = substr($i, 6) }
    if($i ~ /^UB:Z:/) { ub = substr($i, 6) }
    if($i ~ /^GN:Z:/) { gn = substr($i, 6) }
    if($i ~ /^RE:A:/) { re = substr($i ,6) }
    if($i ~ /^xf:i:/) { xf = substr($i, 6) }
  }
  if(cb != "NA" && ub != "NA") {
    print read_id"\t"cb"\t"ub"\t"chr"\t"pos"\t"gn"\t"re"\t"xf
  }
}' >> $OUTPUT_DIR/extracted_reads.tsv
# Append the same metadata from the unmapped BAM file
samtools view $OUTPUT_DIR/unmapped_reads.bam | \
awk '{
  read_id = $1
  chr = $3
  pos = $4
  cb = ub = re = gn = xf = "NA"
  for(i=12;i<=NF;i++){
    if($i ~ /^CB:Z:/) { cb = substr($i, 6) }
    if($i ~ /^UB:Z:/) { ub = substr($i, 6) }
    if($i ~ /^GN:Z:/) { gn = substr($i, 6) }
    if($i ~ /^RE:A:/) { re = substr($i ,6) }
    if($i ~ /^xf:i:/) { xf = substr($i, 6) }
  }
  if(cb != "NA" && ub != "NA") {
    print read_id"\t"cb"\t"ub"\t"chr"\t"pos"\t"gn"\t"re"\t"xf
  }
}' >> $OUTPUT_DIR/extracted_reads.tsv

# -------------------------------
# Run arcasHLA
# ------------------------------- 

# Create output directory for arcasHLA genotype
mkdir -p $OUTPUT_DIR/arcashla_genotype/

# Run arcasHLA genotype on the extracted FASTQ reads, restricting genotyping to HLA class II genes
arcasHLA genotype $OUTPUT_DIR/extracted_reads.fastq \
  --genes DPA1,DPA2,DPB1,DPB2,DQA1,DQA2,DQB1,DQB2,DRA,DRB1,DRB2,DRB3,DRB4,DRB5,DRB6,DRB7,DRB8,DRB9 \
  --single \
  --avg $(head -n 2 $OUTPUT_DIR/extracted_reads.fastq | tail -n 1 | awk '{print length($0)}') \
  --outdir $OUTPUT_DIR/arcashla_genotype/ \
  --temp $TEMP_DIR \
  --threads $(nproc)

# Rename extracted_reads output files to remove the common prefix
for file in $OUTPUT_DIR/arcashla_genotype/extracted_reads.*; do
  base=$(basename $file)
  newname=${base#extracted_reads.}
  mv $file $OUTPUT_DIR/arcashla_genotype/$newname
done

# Retrieve IPD-IMGT/HLA allele sequences for arcasHLA-identified class II alleles
$SCRIPT_DIR/scripts/fetch.HLA.allele.seqs.R \
  -g $OUTPUT_DIR/arcashla_genotype/genotype.json \
  -o $OUTPUT_DIR/arcashla_genotype/ \
  --class-II-only


# -------------------------------
# Re-align reads from chromosome 6 and unmapped reads to allelic-specific HLA reference sequences 
# ------------------------------- 

# Create output directory for allelic expression analysis
mkdir -p $OUTPUT_DIR/allelic_expression/

# Extract reads mapped to chromosome 6 and unmapped reads that contain valid cell barcode (CB) and UMI (UB) tags, retaining the SAM header
samtools view -h $OUTPUT_DIR/cellranger_count/outs/possorted_genome_bam.bam chr6 | awk '$0 ~ /^@/ || ($0 ~ /\tCB:Z:/ && $0 ~ /\tUB:Z:/)' > $OUTPUT_DIR/allelic_expression/chr6_mapped_reads.sam
samtools view -h -f 4 $OUTPUT_DIR/cellranger_count/outs/possorted_genome_bam.bam | awk '$0 ~ /^@/ || ($0 ~ /\tCB:Z:/ && $0 ~ /\tUB:Z:/)' > $OUTPUT_DIR/allelic_expression/unmapped_reads.sam
# Convert SAM files to BAM and merge
samtools view -b -o $OUTPUT_DIR/allelic_expression/chr6_mapped_reads.bam $OUTPUT_DIR/allelic_expression/chr6_mapped_reads.sam
samtools view -b -o $OUTPUT_DIR/allelic_expression/unmapped_reads.bam $OUTPUT_DIR/allelic_expression/unmapped_reads.sam
samtools merge -o $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.bam $OUTPUT_DIR/allelic_expression/chr6_mapped_reads.bam $OUTPUT_DIR/allelic_expression/unmapped_reads.bam
# Remove intermediate SAM and BAM files to save disk space
rm $OUTPUT_DIR/allelic_expression/chr6_mapped_reads.sam $OUTPUT_DIR/allelic_expression/unmapped_reads.sam $OUTPUT_DIR/allelic_expression/chr6_mapped_reads.bam $OUTPUT_DIR/allelic_expression/unmapped_reads.bam

# Convert merged BAM file to FASTQ for downstream allele-specific alignment
samtools fastq $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.bam > $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.fastq

# Create a TSV file listing read ID, cell barcode, UMI, chromosome, and genomic position for all reads with valid CB and UB tags
samtools view $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.bam | \
awk '{
  read_id=$1;
  chr=$3;
  pos=$4;
  cb="NA";
  ub="NA";
  re="NA";
  for(i=12;i<=NF;i++){
    if($i ~ /^CB:Z:/) { cb=substr($i,6) }
    if($i ~ /^UB:Z:/) { ub=substr($i,6) }
    if($i ~ /^RE:A:/) { re=substr($i,6,1) }
  }
  if(cb != "NA" && ub != "NA") {
    print read_id"\t"cb"\t"ub"\t"chr"\t"pos"\t"re
  }
}' > $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.tsv

# Align extracted reads against arcasHLA-derived HLA allele sequences
# Note:
# 1) STAR (used by Cell Ranger) has a default --outFilterMismatchNoverReadLmax = 0.04 (see STAR manual), meaning the maximum allowed mismatches per read pair is 4% of read length, therefore --id is set to 0.96 to match Cell Ranger's default mismatch tolerance
# 2) Cell Ranger only counts reads that overlap an exon by at least 50% (see Cell Ranger algorithm documentation), therefore --query_cov is set to 0.5 to ensure a minimum 50% alignment coverage
# 3) --maxaccepts and --maxrejects are set to 0 to force vsearch to search the entire database for each query read and to report all matches (see vsearch manual)
vsearch --usearch_global $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.fastq --db $OUTPUT_DIR/arcashla_genotype/genotype.fasta \
  --id 0.96 \
  --query_cov 0.5 \
  --strand both \
  --maxaccepts 0 \
  --maxrejects 0 \
  --userfields query+target+id+qcov+mism+gaps+qilo+qihi+tilo+tihi \
  --userout $OUTPUT_DIR/allelic_expression/hla_alignments.tsv


# -------------------------------
# Construct allele count matrix
# ------------------------------- 

# Use read metadata and realigned reads to generate a sparse allele Ã— cell barcode matrix, counting unique UMIs per (unique) allele-barcode combination
$SCRIPT_DIR/scripts/calculate.allele.count.matrix.R \
  --reads $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.tsv \
  --alignments $OUTPUT_DIR/allelic_expression/hla_alignments.tsv \
  --gtf $REF_TRANSCRIPTOME/genes/genes.gtf.gz \
  --output-dir $OUTPUT_DIR/allelic_expression/

# Clean up intermediate alignment and read files
rm $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.bam $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.fastq $OUTPUT_DIR/allelic_expression/chr6_and_unmapped_reads.tsv $OUTPUT_DIR/allelic_expression/hla_alignments.tsv


# -------------------------------
# Integrate allelic counts into Seurat object
# ------------------------------- 