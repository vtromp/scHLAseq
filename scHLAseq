#!/usr/bin/env bash

# Resolve the absolute path to the directory where this script is located, allowing helper scripts and resources to be referenced reliably regardless of the current working directory or how the script was invoked
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Make sure all scripts in the scripts directory are executable
chmod +x $SCRIPT_DIR/scripts/*


# -------------------------------
# Initialize variables
# -------------------------------

# Empty variables to store user-provided paths
FASTQS=""
REF_TRANSCRIPTOME=""
OUTPUT_DIR=""
TEMP_DIR=""


# -------------------------------
# Define a help/usage function
# -------------------------------

# Explain each expected command-line option
usage() {
  echo "Usage: $0 -f <FASTQ_DIR> -l <READ_LENGTH> -r <REF_TRANSCRIPTOME_DIR> -o <OUTPUT_DIR> -t <TEMP_DIR>"
  echo
  echo "  -f FASTQ_DIR              Directory containing sequencing FASTQ files"
  echo "  -r REF_TRANSCRIPTOME_DIR  Path to CellRanger-compatible reference transcriptome"
  echo "  -o OUTPUT_DIR             Output directory"
  echo "  -t TEMP_DIR               Temporary directory"
  echo
  exit 1
}


# -------------------------------
# Parse command-line options using getopts
# -------------------------------

# Parse command-line options
while getopts ":f:r:o:t:h" opt; do
  case $opt in
    f) FASTQS="$OPTARG" ;;
    r) REF_TRANSCRIPTOME="$OPTARG" ;;
    o) OUTPUT_DIR="$OPTARG" ;;
    t) TEMP_DIR="$OPTARG" ;;
    h) usage ;;
    \?) echo "Invalid option -$OPTARG"; usage ;;
    :) echo "Option -$OPTARG requires an argument"; usage ;;
  esac
done

# Remove trailing slash (if present)
FASTQS=${FASTQS%/}
REF_TRANSCRIPTOME=${REF_TRANSCRIPTOME%/}
OUTPUT_DIR=${OUTPUT_DIR%/}
TEMP_DIR=${TEMP_DIR%/}

# Append the FASTQ directory name to the output path to create a sample-specific output directory
OUTPUT_DIR=$OUTPUT_DIR/$(basename $FASTQS)_scHLAseq


# -------------------------------
# Initialize logging and timestamped info messages
# ------------------------------- 

# Function to print info messages to terminal with timestamp
info() {
  local msg="$1"
   echo "$(date '+%Y-%m-%d %H:%M:%S') $msg"
}

# Redirect all stdout/stderr of commands to log file by default
LOG_FILE=$OUTPUT_DIR/run.log
mkdir -p $OUTPUT_DIR
exec > >(tee -a $LOG_FILE) 2>&1


# -------------------------------
# Run cellranger count
# ------------------------------- 

# Return message with timestamp
info "Running CellRanger count"

# Create output directory for cellranger count
mkdir -p $OUTPUT_DIR/cellranger_count/

# Run the Cell Ranger count pipeline and write BAM files and all output results to 'cellranger_count' directory in output folder
cellranger count --id cellranger_count \
  --fastqs $FASTQS \
  --transcriptome $REF_TRANSCRIPTOME \
  --create-bam true \
  --output-dir $OUTPUT_DIR/cellranger_count \
  --localcores $(nproc) \
  --localmem $(awk '/MemAvailable/ {printf "%.0f\n", $2/1024/1024}' /proc/meminfo)


# -------------------------------
# Extract reads mapping to HLA class II genes and unmapped reads
# ------------------------------- 

# Return message with timestamp
info "Extracting reads mapping to HLA class II genes and unmapped reads"

# Generates a TSV file containing, for each molecule assigned to an HLA class II gene, the corresponding cell barcode (CB) and UMI (UB) combination
$SCRIPT_DIR/scripts/extract.HLAclassII.molecule.info.R \
  --cellranger-out $OUTPUT_DIR/cellranger_count/ \
  --output-file $OUTPUT_DIR/hla_molecule_info_cellranger.tsv

# Extract the filtered cell barcodes from Cell Ranger output
zcat $OUTPUT_DIR/cellranger_count/outs/filtered_feature_bc_matrix/barcodes.tsv.gz > $OUTPUT_DIR/filtered_barcodes.txt
# Create a CB_UB list from the previously generated HLA molecule info file
awk '{print $1 "_" $2}' $OUTPUT_DIR/hla_molecule_info_cellranger.tsv > $OUTPUT_DIR/barcode_umi_pairs.txt

# Filter the BAM to keep only reads whose CB-UB pair is in 'barcode_umi_pairs.txt'
samtools view -h $OUTPUT_DIR/cellranger_count/outs/possorted_genome_bam.bam | awk -v keyfile=$OUTPUT_DIR/barcode_umi_pairs.txt '
BEGIN { while ((getline < keyfile) > 0) keep[$1]=1 }
{
    # Pass through headers unchanged
    if ($0 ~ /^@/) { print; next }
    # For each read, parse CB and UB tags
    for (i=12; i<=NF; i++)
        if ($i ~ /^CB:Z:/) cb=substr($i,6)
        else if ($i ~ /^UB:Z:/) ub=substr($i,6)
    # If both CB and UB exist and the pair is in the whitelist, keep the read
    if (cb && ub && keep[cb "_" ub]) print
    cb=ub=""
}' \
| samtools view -b -o $OUTPUT_DIR/hla_class_II_reads.bam
# Index the filtered BAM file
samtools index $OUTPUT_DIR/hla_class_II_reads.bam

# Filter BAM for unmapped reads that have CB and UB tags and whose CB is in 'filtered_barcodes.txt'
samtools view -h $OUTPUT_DIR/cellranger_count/outs/possorted_genome_bam.bam | awk -v keyfile=$OUTPUT_DIR/filtered_barcodes.txt '
BEGIN { while ((getline < keyfile) > 0) keep[$1]=1 }
{
    # Pass through headers unchanged
    if ($0 ~ /^@/) { print; next }
    # Keep only unmapped reads (FLAG 0x4)
    if (and($2, 4) == 0) next
    cb=""; ub=""
    for (i=12; i<=NF; i++) {
        if ($i ~ /^CB:Z:/) cb=substr($i,6)
        else if ($i ~ /^UB:Z:/) ub=substr($i,6)
    }
    # If CB and UB exist and CB is in whitelist, keep the read
    if (cb!="" && ub!="" && keep[cb]) print
}' \
| samtools view -b -o $OUTPUT_DIR/unmapped_reads.bam
# Index the filtered BAM file
samtools index $OUTPUT_DIR/unmapped_reads.bam

# Remove the 'filtered_barcodes.txt' and 'barcodes_umis.txt' files
rm $OUTPUT_DIR/filtered_barcodes.txt $OUTPUT_DIR/barcode_umi_pairs.txt

# Convert HLA class II reads to FASTQ
samtools fastq $OUTPUT_DIR/hla_class_II_reads.bam > $OUTPUT_DIR/extracted_reads.fastq
# Append unmapped reads to the same FASTQ file
samtools fastq $OUTPUT_DIR/unmapped_reads.bam >> $OUTPUT_DIR/extracted_reads.fastq

# Write TSV header
echo -e "read.id\tbarcode\tumi\tchr\tpos\tgene\tregion\talignment.flag" > $OUTPUT_DIR/extracted_reads.tsv

# Extract read ID, cell barcode (CB), UMI (UB), genomic position, gene name (GN), region annotation (RE), and alignment flag (xf) from the HLA class II BAM file and append the results as a TSV-formatted table
samtools view $OUTPUT_DIR/hla_class_II_reads.bam | \
awk '{
  read_id = $1
  chr = $3
  pos = $4
  cb = ub = re = gn = xf = "NA"
  for(i=12;i<=NF;i++){
    if($i ~ /^CB:Z:/) { cb = substr($i, 6) }
    if($i ~ /^UB:Z:/) { ub = substr($i, 6) }
    if($i ~ /^GN:Z:/) { gn = substr($i, 6) }
    if($i ~ /^RE:A:/) { re = substr($i ,6) }
    if($i ~ /^xf:i:/) { xf = substr($i, 6) }
  }
  if(cb != "NA" && ub != "NA") {
    print read_id"\t"cb"\t"ub"\t"chr"\t"pos"\t"gn"\t"re"\t"xf
  }
}' >> $OUTPUT_DIR/extracted_reads.tsv
# Append the same metadata from the unmapped BAM file
samtools view $OUTPUT_DIR/unmapped_reads.bam | \
awk '{
  read_id = $1
  chr = $3
  pos = $4
  cb = ub = re = gn = xf = "NA"
  for(i=12;i<=NF;i++){
    if($i ~ /^CB:Z:/) { cb = substr($i, 6) }
    if($i ~ /^UB:Z:/) { ub = substr($i, 6) }
    if($i ~ /^GN:Z:/) { gn = substr($i, 6) }
    if($i ~ /^RE:A:/) { re = substr($i ,6) }
    if($i ~ /^xf:i:/) { xf = substr($i, 6) }
  }
  if(cb != "NA" && ub != "NA") {
    print read_id"\t"cb"\t"ub"\t"chr"\t"pos"\t"gn"\t"re"\t"xf
  }
}' >> $OUTPUT_DIR/extracted_reads.tsv

# -------------------------------
# Run arcasHLA
# ------------------------------- 

# Return message with timestamp
info "Running arcasHLA to infer HLA genotype"

# Create output directory for arcasHLA genotype
mkdir -p $OUTPUT_DIR/arcashla_genotype/

# Run arcasHLA genotype on the extracted FASTQ reads, restricting genotyping to HLA class II genes
arcasHLA genotype $OUTPUT_DIR/extracted_reads.fastq \
  --genes DPA1,DPA2,DPB1,DPB2,DQA1,DQA2,DQB1,DQB2,DRA,DRB1,DRB2,DRB3,DRB4,DRB5,DRB6,DRB7,DRB8,DRB9 \
  --single \
  --avg $(head -n 2 $OUTPUT_DIR/extracted_reads.fastq | tail -n 1 | awk '{print length($0)}') \
  --outdir $OUTPUT_DIR/arcashla_genotype/ \
  --temp $TEMP_DIR \
  --threads $(nproc)

# Rename extracted_reads output files to remove the common prefix
for file in $OUTPUT_DIR/arcashla_genotype/extracted_reads.*; do
  base=$(basename $file)
  newname=${base#extracted_reads.}
  mv $file $OUTPUT_DIR/arcashla_genotype/$newname
done

# Retrieve IPD-IMGT/HLA allele sequences for arcasHLA-identified class II alleles
$SCRIPT_DIR/scripts/fetch.HLA.allele.seqs.R \
  -g $OUTPUT_DIR/arcashla_genotype/genotype.json \
  -o $OUTPUT_DIR/arcashla_genotype/ 


# -------------------------------
# Re-align extracted reads from chromosome 6 and unmapped reads to allelic-specific HLA reference sequences 
# ------------------------------- 

# Return message with timestamp
info "Re-aligning extracted reads to arcasHLA-imputed HLA class II alleles"

# Align extracted reads against arcasHLA-derived HLA allele sequences
# Note:
# 1) STAR (used by Cell Ranger) has a default --outFilterMismatchNoverReadLmax = 0.04 (see STAR manual), meaning the maximum allowed mismatches per read pair is 4% of read length, therefore --id is set to 0.96 to match Cell Ranger's default mismatch tolerance
# 2) Cell Ranger only counts reads that overlap an exon by at least 50% (see Cell Ranger algorithm documentation), therefore --query_cov is set to 0.5 to ensure a minimum 50% alignment coverage
# 3) --maxaccepts and --maxrejects are set to 0 to force vsearch to search the entire database for each query read and to report all matches (see vsearch manual)
vsearch --usearch_global $OUTPUT_DIR/extracted_reads.fastq --db $OUTPUT_DIR/arcashla_genotype/genotype.fasta \
  --id 0.96 \
  --query_cov 0.5 \
  --strand plus \
  --maxaccepts 0 \
  --maxrejects 0 \
  --userfields query+target+id+qcov+alnlen+ids+mism+gaps+qilo+qihi+tilo+tihi \
  --userout $OUTPUT_DIR/hla_alignments.tsv


# -------------------------------
# Construct allele count matrix
# ------------------------------- 

# Return message with timestamp
info "Constructing allele count matrix"

# Use read metadata and realigned reads to generate a sparse allele Ã— cell barcode matrix, counting unique UMIs per (unique) allele-barcode combination
$SCRIPT_DIR/scripts/calculate.allele.count.matrix.R \
  --reads $OUTPUT_DIR/extracted_reads.tsv \
  --alignments $OUTPUT_DIR/hla_alignments.tsv \
  --output-dir $OUTPUT_DIR


# -------------------------------
# Integrate allelic counts into Seurat object
# ------------------------------- 

# Return message with timestamp
info "Integrating allelic counts into Cell Ranger filtered feature-barcode matrix and building Seurat object"

$SCRIPT_DIR/scripts/integrate.allele.counts.R \
  --cellranger-out $OUTPUT_DIR/cellranger_count/ \
  --allele-count-matrix $OUTPUT_DIR/allele_count_matrix/ \
  --project-id $(basename $FASTQS) \
  --output-dir $OUTPUT_DIR